# -*- coding: utf-8 -*-
"""Functions.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1K-lkl1b15krZy-pq7m_RetjoeGDxz6Wo
"""

# Functions In Python
# A function is a block of code which only runs when it is called.
# Functions provide better modularity for your application and a high degree of code reusing.
# Good thing about functions is that they are famous with several names. Different programming
# languages name them differently, for example, functions, methods, sub-routines, procedures, etc.
# Functions make your code cleaner and save you a lot of time.
# Python Functions stop us from writing the same logic various times.
# We can bind the logic in one function and then call the same repeatedly.

# In Python a function is defined using the def keyword

# Syntax
# def function_name():
#     code to be executed

# So, why should you learn to use functions?

# Here are 5 clear reasons:

# Avoid repetition (Don't Repeat Yourself – DRY)

# Make your code easier to read

# Easier to fix and debug

# Break complex problems into smaller parts

# Reuse code in different places or even in different programs

# Let's say you're building a program that:
# Asks a user for 3 numbers
# Calculates their square
# Calculates their cube
# Prints all results

numbers = [2, 3, 4]

for num in numbers:
    square = num * num
    cube = num * num * num
    print(f"Number: {num}, Square: {square}, Cube: {cube}")

# FUNCTION WITHOUT PARAMETER

# FUNCTION DEFINITION
def greet():
  print('Hello User. Good Evening. How Are You Today')

# FUNCTION CALLING
greet()
greet()
greet()

# FUNTION WITH PARAMETER
# Function parameters are variables defined in the declaration or definition
# of a function. They act as placeholders for the values (arguments) that will be
# passed into the function when it is called.

# function definition
def myfunction(a,b):
  print('Firt Value Is:',a)
  print('Second Value Is:',b)

# function calling
# accept some information from you
# a=10 b=20
myfunction(10,20)
myfunction('siti','fiyda')

# FUNCTION WITH PARAMETERS

def checkEvenOdd(num):
  if num%2==0:
    print('Even Number')
  else:
      print('Odd Number')

# checkEvenOdd(num) --> num is a parameter

checkEvenOdd(10)
checkEvenOdd(11)

def add2Numbers(a,b):
  print(f'sum of a+b is {a+b}')
add2Numbers(10,30)

# Function With Return Statement
# A function with a return statement is a block of code that performs a task and sends back a result

def checkEvenOdd(num):
  return num%2==0

res = checkEvenOdd(13)

if res:
  print('Even Number')
else:
  print('Odd Number')

# check whether the string is Palindrome or not

def checkPalindrome(val):
  return val == val[::-1]   # the -1 here is used to reverse the string.

str1 = "madam"
res = checkPalindrome(str1)

if res:
  print('Palindrome String')
else:
  print('Not A Palindrome')

# Text To Speech

!pip install gTTS

def textToSpeech(user_input):   # name it
  from gtts import gTTS
  tts = gTTS(user_input)        # must follow the def name
  tts.save('output.mp3')        # can put any name

user_input = input('Enter Any Text :')
textToSpeech(user_input)

'''The pass Statement
In Python, the pass is the keyword, which won’t do anything. Sometimes there is a
situation where we need to define a syntactically empty block. We can define that
block using the pass keyword.
When the interpreter finds a pass statement in the program, it returns no operation.
'''

def complicated_func():
  pass

print('Rest Of The Code')

# using *args (meaning arguments)
# Special Symbol used for passing arguments
# *args --> it can handle any number of arguments

# *args collect arguments into a TUPLE

def myfunction(*args):      # *args = (10,20,30)
  print(type(args))
  print(*args)

myfunction(10,20,30)
myfunction(90,100,120,150)
myfunction(90,100)
myfunction(10)
myfunction(45,100,64,72,90,200)

def myfunction(*args):         # args = (90,100,120,150)
  sum = 0                      # sum = 90
  for i in args:               # i --> 100
    sum = sum + i              # sum = 90 + 100
  print(sum)

myfunction(10,20,30)
myfunction(90,100,120,150)
myfunction(90,100)
myfunction(10)

# *args is a variable name for a tuple
def myfunction(*fiyda):
  print(sum(fiyda))

myfunction(10,20,30)
myfunction(90,100,120,150)
myfunction(90,100)
myfunction(10)

# using *args print all the even numbers
def printEvens(*args):  # args = (10,13,11,12,16,17,21,24,26,55,54,70,99,31)
  for i in args:
    if i%2==0:
      print(i,end=' ')
  print()

printEvens(10,13,11,12,16,17,21,24,26,55,54,70,99,31)
printEvens(10,13,11,12,16,17,21,24)
printEvens(10,13,11,16)

def printEvens(*args):
  evens = [i for i in args if i%2==0]     # using nested list comprehension
  print(evens)

printEvens(10,13,11,12,16,17,21,24,26,55,54,70,99,31)
printEvens(10,13,11,12,16,17,21,24)

# Lambda function / Anonymous function
'''
Python Anonymous/Lambda Function

Sometimes we need to declare a function without any name. The nameless property function is called an anonymous
function or lambda function.
The reason behind the using anonymous function is for instant use, that is, one-time usage.
Normal function is declared using the def function. Whereas the anonymous function is declared
using the lambda keyword.

Syntax of lambda function:
lambda: argument_list:expression

When we define a function using the lambda keyword, the code is very concise
so that there is more readability in the code. A lambda function can have any
number of arguments but return only one value after expression evaluation.
'''
# A lambda function can have any number of arguments , but can only have one expression

def square(num):
  return num*num

print(square(3))
print(square(5))

x = lambda num: num*num
print(x(3))
print(x(5))

(lambda num: num*num) (10)

# A lambda function can have any number of arguments , but can only have one expression
(lambda a,b: a+b) (10,20)

num_list = [2,3,4,5,6,7,8,9,10,11,12,13,14,15]
# create a new list for me showing all the even numbers
# this list should be created using a function

(lambda num_list: [ i for i in num_list if i%2==0]) (num_list)

num_list = [2,3,4,5,6,7,8,9,10,11,12,13,14,15]
def even(num_list):
  return [num for num in num_list if num % 2 == 0]
print(even(num_list))

# filter()
# it is used to return the filtered values
# it is used to filter the values based on some condition
# Syntax
# filter(function,sequence)
# You use list() because filter() returns a filter object, not a list.

num_list = [2,3,4,5,6,7,8,9,10,11,12,13,14,15]
list(filter(lambda x: x%2==0,num_list))

def is_even(num):
  return num%2==0

num_list = [2,3,4,5,6,7,8,9,10,11,12,13,14,15]
list(filter(is_even,num_list))

marks = [45,78,87,90,32,65,69]
# Return a new list containing marks greater than 70

list(filter(lambda f: f>70,marks))

names = ["Abdul", "Arif","Yunus","Parag","Haris","Ahmad"]
# show me those names only starts with A
list(filter(lambda name: name.startswith('A'), names))

# map()
# map() is used to apply some functionalities for every item
# present in the given sequence

# map(function,sequence)

list1 = [2,3,4,5,6,7,8,9]
# return a new list containing the square of all numbers
list(map(lambda x: x*x,list1))